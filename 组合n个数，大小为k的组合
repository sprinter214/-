class Solution {
public:
    vector<int> path;             初始化：定义一个路径向量 path 来存储当前组合，定义一个二维向量 ans 来存储所有组合结果，
    vector<vector<int>> ans;                 变量 k 代表组合的目标长度。   关键参数path ans k d
    int k;
    void dfs(int n)   //当前递归可选择的最大数字
    {
        int d=k-path.size();           计算当前还需要选择的元素个数 d。如果 d 为 0，表示当前路径已经形成一个完整的组合，将其添加到 ans 中。
        if(d==0)
        {
            ans.emplace_back(path);     //函数emplace_back 类似于push_back;
            return;
        }
        for(int j=n;j>=d;j--)         遍历从 n 到 d 之间的所有数字。这里选择从大到小遍历，可以避免重复的组合。
        {
            path.push_back(j);       这三行代码是回溯算法的核心部分，它们分别表示选择一个元素、递归处理剩下的元素、以及撤销选择（回溯）的过程。
            dfs(j-1);           //下一层中只考虑比当前元素 j 更小的元素，以生成组合。具体来说：
            path.pop_back();            撤销前面做出的选择，将最后添加的元素从 path 中移除。这一步表示回溯，即撤销之前的选择，以便尝试其他可能的组合。
        }
    }
    vector<vector<int>> combine(int n, int k) {
     path.clear();          // 确保路径为空
        ans.clear();         // 确保结果集为空              确保每次调用 combine 时，这两个容器都是空的，以免受到之前调用的影响。现实中会反复调用。
        path.resize(k);
        dfs(n);
        return ans;
    }
};/////////////////////超出时间限制？？         把path.resize(k);改为this->k=k;  你并不需要提前调整 path 的大小，因为你是在递归过程中动态地增加和减少元素。
这段代码利用回溯法（Backtracking）生成所有可能的组合。通过递归的方式，在每个位置选择一个数，并尝试所有可能的数，形成所有组合。
当路径长度达到目标长度 k 时，保存结果并回溯。这种方法能够保证不漏掉任何一种组合，同时也能避免重复。

从大到小遍历能够避免重复，是因为这种方式确保了每次递归选择时，后续只能选择比当前元素小的元素，从而避免了在组合中出现相同元素顺序的不同排列。
比如说，若从 1 开始递归，可能会产生 [1, 2, 3] 和 [1, 3, 2] 这种不同顺序的相同组合，但在从大到小遍历的情况下，只会产生 [3, 2, 1] 这一个组合。
关于j>=d，如果当前剩余可选择的数字数量不足以达到目标长度，就不需要继续尝试，因为即使继续选择也不能满足组合的要求。
