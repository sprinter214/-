class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n,1);
        for(int i=1;i<m;i++)
        {
            for(int j=1;j<n;j++)     //滚动dp数组dp[j]存储某列每行到达该地点的路线数量
            {
                dp[j]=dp[j-1]+dp[j];  f[j]是表示当前行位置(i, j)的路径数，而f[j-1]是表示当前位置左边的路径数，f[j]原来的值是上一行当前位置的路径数。
            }    左边的都是当前行，而f[j]右边的都是上一行的数据。
        }
        return dp[n-1];
    }
};
核心思路：
到达某个格子 (i, j) 的路径数等于从上方 (i-1, j) 和左侧 (i, j-1) 到达这个格子的路径数之和。
  滚动数组优化：通过一维数组 f 来记录当前行各列的路径数，
  初始时，每一行的第一列路径数为1（即只有一条路径）。然后，逐行更新每个格子的路径数，最终得到从起点到终点的路径总数。
