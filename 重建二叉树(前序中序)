class Solution {
public:
    unordered_map<int,int> index;                //简历哈希表直接找出中序遍历根节点的值
    TreeNode* rebuildTree(const vector<int>& preorder,const vector<int>& inorder,int preleft,int preright,int inoleft,int inoright)
    {
        if(preleft>preright)
        return nullptr;
        int pre_root=preleft;
        int ino_root=index[preorder[pre_root]];                        ////简历哈希表直接找出中序遍历根节点的值
        TreeNode* root=new TreeNode(preorder[preleft]);                                             //先把根节点建立出来(关键)
        int distance=ino_root-inoleft;
        root->left=rebuildTree(preorder,inorder,preleft+1,preleft+distance,inoleft,ino_root-1);       //递归地构造左子树，并连接到根节点           
        root->right=rebuildTree(preorder,inorder,preleft+distance+1,preright,ino_root+1,inoright);    //递归地构造右子树，并连接到根节点
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n=inorder.size();
        for(int i=0;i<n;i++)
        {
            index[inorder[i]]=i;
        }
        return rebuildTree(preorder,inorder,0,n-1,0,n-1);
    }
};

//////////////////////中序与后序遍历同理
class Solution {
public:
    unordered_map<int,int> index;
    TreeNode* mybulidTree(const vector<int>& inorder,vector<int>& postorder,int inoleft,int inoright,int postleft,int postright)
    {
        if(postleft>postright)
        return nullptr;
        int postroot=postright;
        int inoroot=index[postorder[postroot]];
        int distance=inoroot-inoleft;
        TreeNode *Node=new TreeNode(postorder[postroot]);
        Node->left=mybulidTree(inorder,postorder,inoleft,inoroot-1,postleft,postleft+distance-1);
        Node->right=mybulidTree(inorder,postorder,inoroot+1,inoright,postleft+distance,postright-1);
        return Node;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int n=inorder.size();
        for(int i=0;i<n;i++)
        {
            index[inorder[i]]=i;
        }
        return mybulidTree(inorder,postorder,0,n-1,0,n-1);
    }
};
