给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。
bool wordBreak(string s, vector<string>& wordDict) {
        int n=s.size();
        unordered_set<string> hash;    dp[i]代表从0到i的字符串能由字典里的词组成 true
        for(auto &str:wordDict)
        {
            hash.emplace(str);    创建哈希表，使用emplace往里塞元素
        }
        vector<bool>dp(n+1);
        dp[0]=true;
        for(int i=1;i<=s.size();i++)      遍历dp[i]
        {
            for(int j=0;j<i;j++)
            {
                if(dp[j]&&hash.find(s.substr(j,i-j))!=hash.end())
                {
                    dp[i]=true;    
                    break;
                }
            }
        }
        return dp[n];
    }
};、
  j 从 0 开始，是为了检查从第 0 个字符到第 i 个字符的所有可能拆分点。具体来说：
当 j=0 时，检查的是 s[0:i] 是否在字典中。
当 j=1 时，检查的是 s[1:i] 是否在字典中，前面的部分 s[0:1] 已经在之前的判断中确认是否可拆分。
依此类推，遍历 j=0 到 j=i-1 的所有情况，确保每个可能的拆分点都被检查到。
