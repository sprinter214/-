void bubbsort(int arr[],int length)           冒泡排序  //是稳定算法
{
  for(int i=0;i<length-1;i++)  //外层循环控制有多少轮冒泡，是n-1轮，因为冒到最后下标为0的位置以不用再冒
  {
    for(int j=0;j<length-1-i;j++)//内层循环在每一轮冒泡中从第一个位置到未排序的最后一个位置进行比较相邻的两个元素 arr[j] 和 arr[j+1]
    {
      if(arr[j]>arr[j+1])      下标为j和j+1
      {
        int temp=arr[j];
        arr[j]=arr[j+1];
        arr[j+1]=temp;
      }
    }
  }
}
思路概括：              
外层循环：控制整体的排序过程，需要进行 length - 1 轮遍历。
内层循环：在每一轮遍历中，比较相邻的两个元素 arr[j] 和 arr[j+1]，如果前者大于后者，则交换它们的位置。
逐步排序：经过一轮内层循环后，当前未排序部分的最大元素被移动到数组的最后。在接下来的轮次中，内层循环范围逐渐缩小，直到整个数组有序。
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void sclectsort(int arr[],int length)  //选择排序  不稳定，如当前的min被交换到后面之后，会打乱有相同元素的顺序。
{
   for(int i=0;i<length-1;i++)  遍历数组的每个元素，假设当前位置 i 是最小元素的位置 min
   {
     int min=i;
     for(int j=i+1;j<length;j++)  //从当前位置 i 的下一个位置开始，遍历剩余未排序的元素，找出其中的最小值，并更新 min。
     {
       if(arr[j]<arr[min])    //关键的内循环逻辑
       min=j;
     }
     swap(arr[i],arr[min]); //swap在algorithm中自带，并不需要显式地提供引用符。
   }
}
核心思路：
通过多次遍历数组，将未排序部分的最小元素找到并放置到已排序部分的末尾。
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void insert_sort(int arr[],int len)  //升序，不稳定
{
  int j,key;
  for(int i=1;i<len;i++)//从第二个开始，假设第一个已经排好
  {
    key=arr[i];
    j=i-1;                 //j 是用来扫描已排序部分的索引
     while(j>0&&arr[j]>key) // 判断条件的位置  arr[j] > key： 这个条件检查 arr[j]（当前扫描到的已排序部分的元素）是否大于 key
    {                       //j >= 0： 这个条件检查 j 是否在数组的有效范围内
      arr[j+1]=arr[j];
      j--;
    }
    arr[j+1]=key;
  }
}
核心思路：
初始分组： 将数组分为已排序部分和未排序部分。初始时，已排序部分只有第一个元素，未排序部分包含其余元素。
逐步插入： 从未排序部分取出一个元素（key），在已排序部分中找到合适的位置，将 key 插入进去。
