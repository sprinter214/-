 bool canJump(vector<int>& nums) {
        int n=nums.size();
        int dp[n];
        dp[0]=nums[0];  dp[0]表示从第一个位置能够跳到的最远距离，初始值为nums[0]。
        for(int i=1;i<n;i++)
        {
            if(i>dp[i-1])         ////////////k是道路，i是人的位置，只要道路不断延伸，就能走到终点，若i>k,则退出遍历，必定走不到终点。若循环能完整结束，则说明能到重点
            return false;
            dp[i]=max(dp[i-1],i+nums[i]);
        }
        return true;////////////////////////跳跃游戏，使用动态规划，dp存储能够跳跃的最大值。

核心思路是使用动态规划来记录每个位置可以到达的最远距离。
初始化：
dp[0]表示从第一个位置能够跳到的最远距离，初始值为nums[0]。
遍历数组：

对于每个位置i，首先检查是否能够从之前的位置跳到当前位置，即i <= dp[i-1]。如果不能，则返回false，表示无法到达最后一个位置。
如果能到达当前位置，则更新dp[i]为从当前位置跳跃能够到达的最远距离max(dp[i-1], i + nums[i])。
返回结果：

如果遍历完成而未返回false，则表示可以到达最后一个位置，返回true。
总结
该算法通过动态规划跟踪每个位置可以到达的最远距离，逐步判断是否能够到达终点。核心在于检查每个位置是否可达，并更新到达该位置后的最远距离。
